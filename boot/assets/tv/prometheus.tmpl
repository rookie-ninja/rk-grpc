{{define "prometheus"}}
<!DOCTYPE html>
<html lang="en" class="color-toggle-light" color-mode="light">
{{template "head"}}

<body>
{{template "svg-sprite"}}
<style>
.card{
  box-shadow: 0 6px 10px rgba(0,0,0,.08), 0 0 6px rgba(0,0,0,.05);
  padding: 10% 10% 10% 10%;
}
.card-metrics{
  box-shadow: 0 6px 10px rgba(0,0,0,.08), 0 0 6px rgba(0,0,0,.05);
  padding: 3% 3% 3% 3%;
}
</style>

<div class="wrapper dark-mode-dim">
  {{template "header"}}
  <main class="container flex flex-even">
  {{template "aside"}}
    <!--- main page --->
    <div class="gdoc-page">
      <!--- header nav --->
      <div class="gdoc-page__header flex flex-wrap justify-between">
        <div>
          <svg class="icon gdoc_path hidden-mobile"><use xlink:href="#gdoc_path"></use></svg>
          <ol class="breadcrumb">
            <li><a href="/rk/v1/tv/prometheus"><span itemprop="name">Metrics</span></a></li>
            <li>/</li>
            <li><span itemprop="name">Prometheus</span></li>
          </ol>
        </div>
      </div>
      <!--- content --->
      <article class="gdoc-markdown">
        <!--- Env Overview --->
        <div class="gdoc-page__anchorwrap"><h1 id="Prometheus"> Prometheus </h1></div>
        <div class="gdoc-columns flex flex-wrap">
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card">
              <h3 id="left"> CPU Used </h3>
              <span id="cpu_curr" style="display:block">0 %</span>
            </div>
          </div>
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card">
              <h3 id="mid-content"> Mem Used </h3>
              <span id="mem_curr" style="display:block">0 MB</span>
            </div>
          </div>
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card">
              <h3 id="right-content"> Req Count </h3>
              <span id="req_total" style="display:block">0</span>
            </div>
          </div>
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card">
              <h3 id="right-content"> Up time </h3>
              <span id="up_time" style="display:block">0</span>
            </div>
          </div>
        </div>
        <!-- API DROPDOWN -->
        <div class="gdoc-columns flex flex-wrap">
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <select id="API" style="font-size: 20px;">
              <option selected>Select API</option>
            </select>
          </div>
        </div>
        <!-- Metrics -->
        <div class="gdoc-columns flex flex-wrap">
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card-metrics"><canvas id="REQ_PER_SEC"></canvas></div>
          </div>
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card-metrics"><canvas id="RES_CODE"></canvas></div>
          </div>
        </div>
        <!--- P50 --->
        <div class="gdoc-columns flex flex-wrap">
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card-metrics"><canvas id="REQ_ELAPSED_P50"></canvas></div>
          </div>
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card-metrics"><canvas id="REQ_ELAPSED_P90"></canvas></div>
          </div>
        </div>
        <!--- P90 --->
        <div class="gdoc-columns flex flex-wrap">
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card-metrics"><canvas id="REQ_ELAPSED_P99"></canvas></div>
          </div>
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card-metrics"><canvas id="REQ_ELAPSED_P999"></canvas></div>
          </div>
        </div>
        <!--- P99 --->
        <div class="gdoc-columns flex flex-wrap">
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card-metrics"><canvas id="CPU"></canvas></div>
          </div>
          <div class="gdoc-columns__content gdoc-markdown--nested flex-even">
            <div class="card-metrics"><canvas id="MEM"></canvas></div>
          </div>
        </div>
      </article>
    </div>
  </main>
  {{template "footer"}}
</div>

<script src="https://thingsinjars.com/lab/scoped/jquery.scoped.js"></script>
<script>
  let intervalMS = 2000
  let maxLength = 10
  let cpuStat = [{
    x: new Date().toISOString(),
    y: 0,
  }];
  let memStat = [{
    x: new Date().toISOString(),
    y: 0,
  }];
  let emptyStat = [{
    x: new Date().toISOString(),
    y: 0,
  }];
  let reqPerSecMap = new Map();
  let reqElapsedP50 = new Map();
  let reqElapsedP90 = new Map();
  let reqElapsedP99 = new Map();
  let reqElapsedP999 = new Map();
  let reqPrevMap = new Map();
  let reqResCodeLabel = new Map();
  let reqResCodeData = new Map();
  let reqResCodeColor = new Map();

  let colors = ['#007bff','#28a745','#333333','#c3e6cb','#dc3545','#6c757d'];
  let CPU = new Chart(document.getElementById("CPU"), {
    type: 'line',
    data: {
      datasets: [{
        data: cpuStat,
        backgroundColor: colors[3],
        borderColor: colors[1],
        borderWidth: 1,
        pointBackgroundColor: colors[1]
      }]
    },
    options: {
      title: {
        display: true,
        text: 'CPU'
      },
      scales: {
        xAxes: [{
          type: 'time',
          time: {
            unit: 'second',
            displayFormats: {
              quarter: 'HH:MM:SS'
            }
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: '%',
           },
           ticks: {
             suggestedMin: 0,
             beginAtZero: true
           }
        }]
      },
      legend: false
    }
  });
  let MEM = new Chart(document.getElementById("MEM"), {
    type: 'line',
    data: {
      datasets: [{
        data: memStat,
        backgroundColor: colors[3],
        borderColor: colors[1],
        borderWidth: 1,
        pointBackgroundColor: colors[1]
      }]
    },
    options: {
      title: {
        display: true,
        text: 'MEM'
      },
      scales: {
        xAxes: [{
          type: 'time',
          time: {
            unit: 'second',
            displayFormats: {
              quarter: 'HH:MM:SS'
            }
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'MB',
          },
          ticks: {
            suggestedMin: 0,
            beginAtZero: true,
          }
        }]
      },
      legend: false
    }
  });
  let REQ_PER_SEC = new Chart(document.getElementById("REQ_PER_SEC"), {
    type: 'line',
    data: {
      datasets: [{
        label: 'api',
        data: emptyStat,
        backgroundColor: colors[3],
        borderColor: colors[1],
        borderWidth: 1,
        pointBackgroundColor: colors[1]
      }]
    },
    options: {
      title: {
        display: true,
        text: 'Request Per Sec'
        },
      scales: {
        xAxes: [{
          type: 'time',
          time: {
            unit: 'second',
            displayFormats: {
              quarter: 'HH:MM:SS'
            }
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'Count',
          },
          ticks: {
            suggestedMin: 0,
            beginAtZero: true,
          }
        }]
      },
      legend: {
        position: "bottom"
      },
    }
  });
  let REQ_ELAPSED_P50 = new Chart(document.getElementById("REQ_ELAPSED_P50"), {
    type: 'line',
    data: {
      datasets: [{
        label: 'api',
        data: emptyStat,
        backgroundColor: colors[3],
        borderColor: colors[1],
        borderWidth: 1,
        pointBackgroundColor: colors[1]
      }]
    },
    options: {
      title: {
        display: true,
        text: 'Elapsed P50'
      },
      scales: {
        xAxes: [{
          type: 'time',
          time: {
            unit: 'second',
            displayFormats: {
              quarter: 'HH:MM:SS'
            }
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'ms',
          },
          ticks: {
            suggestedMin: 0,
            beginAtZero: true,
          }
        }]
      },
      legend: {
        position: "bottom"
      },
    }
  });
  let REQ_ELAPSED_P90 = new Chart(document.getElementById("REQ_ELAPSED_P90"), {
    type: 'line',
    data: {
      datasets: [{
        label: 'api',
        data: emptyStat,
        backgroundColor: colors[3],
        borderColor: colors[1],
        borderWidth: 1,
        pointBackgroundColor: colors[1]
      }]
    },
    options: {
      title: {
        display: true,
        text: 'Elapsed P90'
      },
      scales: {
        xAxes: [{
          type: 'time',
          time: {
            unit: 'second',
            displayFormats: {
              quarter: 'HH:MM:SS'
            }
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'ms',
          },
          ticks: {
            suggestedMin: 0,
            beginAtZero: true,
          }
        }]
      },
      legend: {
        position: "bottom"
      },
    }
  });
  let REQ_ELAPSED_P99 = new Chart(document.getElementById("REQ_ELAPSED_P99"), {
    type: 'line',
    data: {
      datasets: [{
        label: 'api',
        data: emptyStat,
        backgroundColor: colors[3],
        borderColor: colors[1],
        borderWidth: 1,
        pointBackgroundColor: colors[1]
      }]
    },
    options: {
      title: {
        display: true,
        text: 'Elapsed P99'
      },
      scales: {
        xAxes: [{
          type: 'time',
          time: {
            unit: 'second',
            displayFormats: {
              quarter: 'HH:MM:SS'
            }
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'ms',
          },
          ticks: {
            suggestedMin: 0,
            beginAtZero: true,
          }
        }]
      },
      legend: {
        position: "bottom"
      },
    }
  });
  let REQ_ELAPSED_P999 = new Chart(document.getElementById("REQ_ELAPSED_P999"), {
    type: 'line',
    data: {
      datasets: [{
        label: 'api',
        data: emptyStat,
        backgroundColor: colors[3],
        borderColor: colors[1],
          borderWidth: 1,
          pointBackgroundColor: colors[1]
      }]
    },
    options: {
      title: {
        display: true,
        text: 'Elapsed P99.9'
      },
      scales: {
        xAxes: [{
          type: 'time',
          time: {
            unit: 'second',
            displayFormats: {
              quarter: 'HH:MM:SS'
            }
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'ms',
          },
          ticks: {
            suggestedMin: 0,
            beginAtZero: true,
          }
        }]
      },
      legend: {
        position: "bottom"
      },
    }
  });
  let RES_CODE = new Chart(document.getElementById("RES_CODE"), {
    type: 'doughnut',
    data: {
      labels: [],
      datasets: [{
        label: "Response Code",
        backgroundColor: [],
        data: []
      }]
    },
    options: {
      title: {
        display: true,
        text: 'Response Code'
      }
    }
  });

  var remoteURL = window.location.protocol + '//' + window.location.hostname + ':' + window.location.port;
  $(document).ready(function() {
    $.ajax({
      url : remoteURL + '/rk/v1/apis',
      type : 'GET',
      dataType : 'json',
      success : function(data) {
        reloadAPI(data)
      },
      error: function() {}
    });
    setInterval(function() {
      $.ajax({
        url : remoteURL + '/rk/v1/sys',
        type : 'GET',
        dataType : 'json',
        success : function(data) {
          reloadSys(data.cpuInfo.cpuUsedPercentage, data.memInfo.memUsedMb, data.goEnvInfo.upTimeStr)
          CPU.update()
          MEM.update()
        },
        error: function(request, status, error) {
          reloadSys(0, 0, 0)
          CPU.update()
          MEM.update()
        }
      });
    }, intervalMS);
    setInterval(function() {
      $.ajax({
        url : remoteURL + '/rk/v1/req',
        type : 'GET',
        dataType : 'json',
        success : function(data) {
          processResponse(data)
          REQ_PER_SEC.update()
          REQ_ELAPSED_P50.update()
          REQ_ELAPSED_P90.update()
          REQ_ELAPSED_P99.update()
          REQ_ELAPSED_P999.update()
          RES_CODE.update()
        },
        error: function() {
          processResponse({})
          REQ_PER_SEC.update()
          REQ_ELAPSED_P50.update()
          REQ_ELAPSED_P90.update()
          REQ_ELAPSED_P99.update()
          REQ_ELAPSED_P999.update()
          RES_CODE.update()
        }
      });
    }, intervalMS);
  });

  // on selection
  $(function() {
    $('select').on('change', function(e){
      // clear it first
      REQ_PER_SEC.data.datasets[0].data = emptyStat
      REQ_ELAPSED_P50.data.datasets[0].data = emptyStat
      REQ_ELAPSED_P90.data.datasets[0].data = emptyStat
      REQ_ELAPSED_P99.data.datasets[0].data = emptyStat
      REQ_ELAPSED_P999.data.datasets[0].data = emptyStat

      // select datasets from map
      if (reqPerSecMap.has(this.value)) {
        REQ_PER_SEC.data.datasets[0].label = this.value
        REQ_PER_SEC.data.datasets[0].data = reqPerSecMap.get(this.value)

        REQ_ELAPSED_P50.data.datasets[0].label = this.value
        REQ_ELAPSED_P50.data.datasets[0].data = reqElapsedP50.get(this.value)

        REQ_ELAPSED_P90.data.datasets[0].label = this.value
        REQ_ELAPSED_P90.data.datasets[0].data = reqElapsedP90.get(this.value)

        REQ_ELAPSED_P99.data.datasets[0].label = this.value
        REQ_ELAPSED_P99.data.datasets[0].data = reqElapsedP99.get(this.value)

        REQ_ELAPSED_P999.data.datasets[0].label = this.value
        REQ_ELAPSED_P999.data.datasets[0].data = reqElapsedP999.get(this.value)

        RES_CODE.data.labels = reqResCodeLabel.get(this.value)
        RES_CODE.data.datasets[0].data = reqResCodeData.get(this.value)
        RES_CODE.data.datasets[0].backgroundColor = reqResCodeColor.get(this.value)
      }
    });
  });

  function reloadSys(cpu, mem, up) {
    if (cpuStat.length > maxLength) {
      cpuStat.shift()
    }

    if (memStat.length > maxLength) {
      memStat.shift()
    }

    var now = new Date();
    cpuStat.push({
      x: now.toISOString(),
      y: cpu,
    })

    memStat.push({
      x: now.toISOString(),
      y: mem,
    })

    document.getElementById("cpu_curr").innerText = cpu+" %"
    document.getElementById("mem_curr").innerText = mem+" MB"
    document.getElementById("up_time").innerText = up
  }

  function processResponse(resp) {
    let reqTotal = 0
    for (let i = 0; i < resp.metrics.length; i++) {
      let metric = resp.metrics[i];
      reloadReqRate(metric)
      reloadResCode(metric)
      reloadElapsed(reqElapsedP50, metric.grpcService+" : "+metric.grpcMethod, metric.elapsedNanoP50)
      reloadElapsed(reqElapsedP90, metric.grpcService+" : "+metric.grpcMethod, metric.elapsedNanoP90)
      reloadElapsed(reqElapsedP99, metric.grpcService+" : "+metric.grpcMethod, metric.elapsedNanoP99)
      reloadElapsed(reqElapsedP999, metric.grpcService+" : "+metric.grpcMethod, metric.elapsedNanoP999)
      reqTotal += metric.count
    }
    document.getElementById("req_total").innerText = reqTotal
  }

  function getRandomColor(size) {
    let res = []
    for (let j = 0; j < size; j++) {
      let letters = '0123456789ABCDEF'.split('');
      let color = '#';
      for (let i = 0; i < 6; i++ ) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      res.push(color)
    }

    return res
  }

  function reloadAPI(apis) {
    for (let i = 0; i < apis.entries.length; i++) {
      let api = document.getElementById("API");
      let op = document.createElement("option");
      console.log(apis.entries[i])
      let linkText = document.createTextNode(apis.entries[i].grpc.service+' : '+apis.entries[i].grpc.method);
      op.appendChild(linkText);
      api.appendChild(op);
    }
  }

  function reloadElapsed(map, path, elapsedQuantile) {
    let now = new Date()
    if (map.has(path)) {
      let array = map.get(path)
      if (array.length > maxLength) {
        array.shift();
      }

      array.push({
        x: now.toISOString(),
        y: elapsedQuantile/1e6,
      })
    } else {
      let elapsed = [{
        x: now.toISOString(),
        y: elapsedQuantile/1e6,
      }]
      map.set(path, elapsed)
    }
  }

  function reloadResCode(metric) {
    let key = metric.grpcService+" : "+metric.grpcMethod
    if (reqResCodeLabel.has(key)) {
      for (let f = 0; f < reqResCodeLabel.get(key).length; f++) {
        reqResCodeLabel.get(key).shift()
      }
    } else {
      reqResCodeLabel.set(key, new Array())
    }

    if (reqResCodeData.has(key)) {
      for (let f = 0; f < reqResCodeData.get(key).length; f++) {
        reqResCodeData.get(key).shift()
      }
      reqResCodeData.get(key).length = 0
    } else {
      reqResCodeData.set(key, new Array())
    }

    if (!reqResCodeColor.has(key)) {
      reqResCodeColor.set(key, new Array())
    }

    for (let j = 0; j < metric.resCode.length; j++) {
      let element = metric.resCode[j]
      reqResCodeLabel.get(key).push(element.resCode + "[" + element.count + "]")
      reqResCodeData.get(key).push(element.count)
    }

    if (reqResCodeColor.get(key).length != reqResCodeLabel.get(key).length) {
      let colors = getRandomColor(reqResCodeLabel.get(key).length - reqResCodeColor.get(key).length)
      for (let k = 0; k < colors.length; k++) {
        reqResCodeColor.get(key).push(colors[k])
      }
    }
  }
  function reloadReqRate(metric) {
    let key = metric.grpcService+" : "+metric.grpcMethod
    if (reqPerSecMap.has(key)) {
      let array = reqPerSecMap.get(key)
      if (array.length > maxLength) {
        array.shift();
      }
      // get prev value
      let prevMetric = reqPrevMap.get(key)
      let prevValue = prevMetric[prevMetric.length-1].count
      let currValue = metric.count

      array.push({
        x: new Date().toISOString(),
        y: (currValue-prevValue)/(intervalMS/1000),
      })
      prevMetric.push(metric)
    } else {
      let perSec = [{
        x: new Date().toISOString(),
        y: metric.count,
      }]
      reqPerSecMap.set(key, perSec)
      reqPrevMap.set(key, [metric])
    }
  }
</script>
</body>
</html>
{{end}}